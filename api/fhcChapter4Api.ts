/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import { XHR } from "./XHR"
import { AddedDocumentPreview } from "../model/AddedDocumentPreview"
import { AgreementResponse } from "../model/AgreementResponse"
import { Appendix } from "../model/Appendix"
import { MppPreview } from "../model/MppPreview"
import { ParagraphInfos } from "../model/ParagraphInfos"
import { ParagraphPreview } from "../model/ParagraphPreview"

export class fhcChapter4Api {
  host: string
  headers: Array<XHR.Header>
  fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>

  constructor(
    host: string,
    headers: any,
    fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>
  ) {
    this.host = host
    this.headers = Object.keys(headers).map(k => new XHR.Header(k, headers[k]))
    this.fetchImpl = fetchImpl
  }

  setHeaders(h: Array<XHR.Header>) {
    this.headers = h
  }

  handleError(e: XHR.XHRError) {
    throw e
  }

  /**
   *
   * @summary agreementRequestsConsultation
   * @param xFHCKeystoreId X-FHC-keystoreId
   * @param xFHCTokenId X-FHC-tokenId
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param hcpNihii hcpNihii
   * @param hcpSsin hcpSsin
   * @param hcpFirstName hcpFirstName
   * @param hcpLastName hcpLastName
   * @param patientSsin patientSsin
   * @param patientDateOfBirth patientDateOfBirth
   * @param patientFirstName patientFirstName
   * @param patientLastName patientLastName
   * @param patientGender patientGender
   * @param civicsVersion civicsVersion
   * @param paragraph paragraph
   * @param start start
   * @param end end
   * @param reference reference
   */
  agreementRequestsConsultationUsingGET(
    xFHCKeystoreId: string,
    xFHCTokenId: string,
    xFHCPassPhrase: string,
    hcpNihii: string,
    hcpSsin: string,
    hcpFirstName: string,
    hcpLastName: string,
    patientSsin: string,
    patientDateOfBirth: number,
    patientFirstName: string,
    patientLastName: string,
    patientGender: string,
    civicsVersion?: string,
    paragraph?: string,
    start?: number,
    end?: number,
    reference?: string
  ): Promise<AgreementResponse | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/consult/${encodeURIComponent(String(patientSsin))}` +
      "?ts=" +
      new Date().getTime() +
      (hcpNihii ? "&hcpNihii=" + encodeURIComponent(String(hcpNihii)) : "") +
      (hcpSsin ? "&hcpSsin=" + encodeURIComponent(String(hcpSsin)) : "") +
      (hcpFirstName ? "&hcpFirstName=" + encodeURIComponent(String(hcpFirstName)) : "") +
      (hcpLastName ? "&hcpLastName=" + encodeURIComponent(String(hcpLastName)) : "") +
      (patientDateOfBirth
        ? "&patientDateOfBirth=" + encodeURIComponent(String(patientDateOfBirth))
        : "") +
      (patientFirstName
        ? "&patientFirstName=" + encodeURIComponent(String(patientFirstName))
        : "") +
      (patientLastName ? "&patientLastName=" + encodeURIComponent(String(patientLastName)) : "") +
      (patientGender ? "&patientGender=" + encodeURIComponent(String(patientGender)) : "") +
      (civicsVersion ? "&civicsVersion=" + encodeURIComponent(String(civicsVersion)) : "") +
      (paragraph ? "&paragraph=" + encodeURIComponent(String(paragraph)) : "") +
      (start ? "&start=" + encodeURIComponent(String(start)) : "") +
      (end ? "&end=" + encodeURIComponent(String(end)) : "") +
      (reference ? "&reference=" + encodeURIComponent(String(reference)) : "")
    let headers = this.headers
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => new AgreementResponse(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary cancelAgreement
   * @param xFHCKeystoreId X-FHC-keystoreId
   * @param xFHCTokenId X-FHC-tokenId
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param hcpNihii hcpNihii
   * @param hcpSsin hcpSsin
   * @param hcpFirstName hcpFirstName
   * @param hcpLastName hcpLastName
   * @param patientSsin patientSsin
   * @param patientDateOfBirth patientDateOfBirth
   * @param patientFirstName patientFirstName
   * @param patientLastName patientLastName
   * @param patientGender patientGender
   * @param decisionReference decisionReference
   * @param iorequestReference iorequestReference
   */
  cancelAgreementUsingDELETE(
    xFHCKeystoreId: string,
    xFHCTokenId: string,
    xFHCPassPhrase: string,
    hcpNihii: string,
    hcpSsin: string,
    hcpFirstName: string,
    hcpLastName: string,
    patientSsin: string,
    patientDateOfBirth: number,
    patientFirstName: string,
    patientLastName: string,
    patientGender: string,
    decisionReference?: string,
    iorequestReference?: string
  ): Promise<AgreementResponse | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/cancel/${encodeURIComponent(String(patientSsin))}` +
      "?ts=" +
      new Date().getTime() +
      (hcpNihii ? "&hcpNihii=" + encodeURIComponent(String(hcpNihii)) : "") +
      (hcpSsin ? "&hcpSsin=" + encodeURIComponent(String(hcpSsin)) : "") +
      (hcpFirstName ? "&hcpFirstName=" + encodeURIComponent(String(hcpFirstName)) : "") +
      (hcpLastName ? "&hcpLastName=" + encodeURIComponent(String(hcpLastName)) : "") +
      (patientDateOfBirth
        ? "&patientDateOfBirth=" + encodeURIComponent(String(patientDateOfBirth))
        : "") +
      (patientFirstName
        ? "&patientFirstName=" + encodeURIComponent(String(patientFirstName))
        : "") +
      (patientLastName ? "&patientLastName=" + encodeURIComponent(String(patientLastName)) : "") +
      (patientGender ? "&patientGender=" + encodeURIComponent(String(patientGender)) : "") +
      (decisionReference
        ? "&decisionReference=" + encodeURIComponent(String(decisionReference))
        : "") +
      (iorequestReference
        ? "&iorequestReference=" + encodeURIComponent(String(iorequestReference))
        : "")
    let headers = this.headers
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    return XHR.sendCommand("DELETE", _url, headers, _body, this.fetchImpl)
      .then(doc => new AgreementResponse(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary closeAgreement
   * @param xFHCKeystoreId X-FHC-keystoreId
   * @param xFHCTokenId X-FHC-tokenId
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param hcpNihii hcpNihii
   * @param hcpSsin hcpSsin
   * @param hcpFirstName hcpFirstName
   * @param hcpLastName hcpLastName
   * @param patientSsin patientSsin
   * @param patientDateOfBirth patientDateOfBirth
   * @param patientFirstName patientFirstName
   * @param patientLastName patientLastName
   * @param patientGender patientGender
   * @param decisionReference decisionReference
   */
  closeAgreementUsingDELETE(
    xFHCKeystoreId: string,
    xFHCTokenId: string,
    xFHCPassPhrase: string,
    hcpNihii: string,
    hcpSsin: string,
    hcpFirstName: string,
    hcpLastName: string,
    patientSsin: string,
    patientDateOfBirth: number,
    patientFirstName: string,
    patientLastName: string,
    patientGender: string,
    decisionReference: string
  ): Promise<AgreementResponse | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/close/${encodeURIComponent(String(patientSsin))}` +
      "?ts=" +
      new Date().getTime() +
      (hcpNihii ? "&hcpNihii=" + encodeURIComponent(String(hcpNihii)) : "") +
      (hcpSsin ? "&hcpSsin=" + encodeURIComponent(String(hcpSsin)) : "") +
      (hcpFirstName ? "&hcpFirstName=" + encodeURIComponent(String(hcpFirstName)) : "") +
      (hcpLastName ? "&hcpLastName=" + encodeURIComponent(String(hcpLastName)) : "") +
      (patientDateOfBirth
        ? "&patientDateOfBirth=" + encodeURIComponent(String(patientDateOfBirth))
        : "") +
      (patientFirstName
        ? "&patientFirstName=" + encodeURIComponent(String(patientFirstName))
        : "") +
      (patientLastName ? "&patientLastName=" + encodeURIComponent(String(patientLastName)) : "") +
      (patientGender ? "&patientGender=" + encodeURIComponent(String(patientGender)) : "") +
      (decisionReference
        ? "&decisionReference=" + encodeURIComponent(String(decisionReference))
        : "")
    let headers = this.headers
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    return XHR.sendCommand("DELETE", _url, headers, _body, this.fetchImpl)
      .then(doc => new AgreementResponse(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary findParagraphs
   * @param searchString searchString
   * @param language language
   */
  findParagraphsUsingGET(
    searchString: string,
    language: string
  ): Promise<Array<ParagraphPreview> | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/sam/search/${encodeURIComponent(String(searchString))}/${encodeURIComponent(
        String(language)
      )}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => (doc.body as Array<JSON>).map(it => new ParagraphPreview(it)))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary findParagraphsWithCnk
   * @param cnk cnk
   * @param language language
   */
  findParagraphsWithCnkUsingGET(
    cnk: number,
    language: string
  ): Promise<Array<ParagraphPreview> | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/sam/bycnk/${encodeURIComponent(String(cnk))}/${encodeURIComponent(
        String(language)
      )}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => (doc.body as Array<JSON>).map(it => new ParagraphPreview(it)))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getAddedDocument
   * @param chapterName chapterName
   * @param paragraphName paragraphName
   * @param verseSeq verseSeq
   * @param docSeq docSeq
   * @param language language
   */
  getAddedDocumentUsingGET(
    chapterName: string,
    paragraphName: string,
    verseSeq: number,
    docSeq: number,
    language: string
  ): Promise<any | Boolean> {
    let _body = null

    const _url =
      this.host +
      `/chap4/sam/docpreview/${encodeURIComponent(String(chapterName))}/${encodeURIComponent(
        String(paragraphName)
      )}/${encodeURIComponent(String(verseSeq))}/${encodeURIComponent(
        String(docSeq)
      )}/${encodeURIComponent(String(language))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => true)
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getAddedDocuments
   * @param chapterName chapterName
   * @param paragraphName paragraphName
   */
  getAddedDocumentsUsingGET(
    chapterName: string,
    paragraphName: string
  ): Promise<Array<AddedDocumentPreview> | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/sam/docpreviews/${encodeURIComponent(String(chapterName))}/${encodeURIComponent(
        String(paragraphName)
      )}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => (doc.body as Array<JSON>).map(it => new AddedDocumentPreview(it)))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getMppsForParagraph
   * @param chapterName chapterName
   * @param paragraphName paragraphName
   */
  getMppsForParagraphUsingGET(
    chapterName: string,
    paragraphName: string
  ): Promise<Array<MppPreview> | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/sam/mpps/${encodeURIComponent(String(chapterName))}/${encodeURIComponent(
        String(paragraphName)
      )}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => (doc.body as Array<JSON>).map(it => new MppPreview(it)))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getParagraphInfos
   * @param chapterName chapterName
   * @param paragraphName paragraphName
   */
  getParagraphInfosUsingGET(
    chapterName: string,
    paragraphName: string
  ): Promise<ParagraphInfos | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/sam/info/${encodeURIComponent(String(chapterName))}/${encodeURIComponent(
        String(paragraphName)
      )}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => new ParagraphInfos(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getVtmNamesForParagraph
   * @param chapterName chapterName
   * @param paragraphName paragraphName
   * @param language language
   */
  getVtmNamesForParagraphUsingGET(
    chapterName: string,
    paragraphName: string,
    language: string
  ): Promise<Array<string> | any> {
    let _body = null

    const _url =
      this.host +
      `/chap4/sam/vtms/${encodeURIComponent(String(chapterName))}/${encodeURIComponent(
        String(paragraphName)
      )}/${encodeURIComponent(String(language))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => (doc.body as Array<JSON>).map(it => JSON.parse(JSON.stringify(it))))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary requestAgreement
   * @param body appendices
   * @param xFHCKeystoreId X-FHC-keystoreId
   * @param xFHCTokenId X-FHC-tokenId
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param hcpNihii hcpNihii
   * @param hcpSsin hcpSsin
   * @param hcpFirstName hcpFirstName
   * @param hcpLastName hcpLastName
   * @param patientSsin patientSsin
   * @param patientDateOfBirth patientDateOfBirth
   * @param patientFirstName patientFirstName
   * @param patientLastName patientLastName
   * @param patientGender patientGender
   * @param requestType requestType
   * @param civicsVersion civicsVersion
   * @param paragraph paragraph
   * @param verses verses
   * @param incomplete incomplete
   * @param start start
   * @param end end
   * @param decisionReference decisionReference
   * @param ioRequestReference ioRequestReference
   */
  requestAgreementUsingPOST(
    xFHCKeystoreId: string,
    xFHCTokenId: string,
    xFHCPassPhrase: string,
    hcpNihii: string,
    hcpSsin: string,
    hcpFirstName: string,
    hcpLastName: string,
    patientSsin: string,
    patientDateOfBirth: number,
    patientFirstName: string,
    patientLastName: string,
    patientGender: string,
    requestType: string,
    civicsVersion: string,
    paragraph: string,
    verses?: string,
    incomplete?: boolean,
    start?: number,
    end?: number,
    decisionReference?: string,
    ioRequestReference?: string,
    body?: Array<Appendix>
  ): Promise<AgreementResponse | any> {
    let _body = null
    _body = body

    const _url =
      this.host +
      `/chap4/new/${encodeURIComponent(String(patientSsin))}/${encodeURIComponent(
        String(civicsVersion)
      )}/${encodeURIComponent(String(requestType))}/${encodeURIComponent(String(paragraph))}` +
      "?ts=" +
      new Date().getTime() +
      (hcpNihii ? "&hcpNihii=" + encodeURIComponent(String(hcpNihii)) : "") +
      (hcpSsin ? "&hcpSsin=" + encodeURIComponent(String(hcpSsin)) : "") +
      (hcpFirstName ? "&hcpFirstName=" + encodeURIComponent(String(hcpFirstName)) : "") +
      (hcpLastName ? "&hcpLastName=" + encodeURIComponent(String(hcpLastName)) : "") +
      (patientDateOfBirth
        ? "&patientDateOfBirth=" + encodeURIComponent(String(patientDateOfBirth))
        : "") +
      (patientFirstName
        ? "&patientFirstName=" + encodeURIComponent(String(patientFirstName))
        : "") +
      (patientLastName ? "&patientLastName=" + encodeURIComponent(String(patientLastName)) : "") +
      (patientGender ? "&patientGender=" + encodeURIComponent(String(patientGender)) : "") +
      (verses ? "&verses=" + encodeURIComponent(String(verses)) : "") +
      (incomplete ? "&incomplete=" + encodeURIComponent(String(incomplete)) : "") +
      (start ? "&start=" + encodeURIComponent(String(start)) : "") +
      (end ? "&end=" + encodeURIComponent(String(end)) : "") +
      (decisionReference
        ? "&decisionReference=" + encodeURIComponent(String(decisionReference))
        : "") +
      (ioRequestReference
        ? "&ioRequestReference=" + encodeURIComponent(String(ioRequestReference))
        : "")
    let headers = this.headers
    headers = headers
      .filter(h => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then(doc => new AgreementResponse(doc.body as JSON))
      .catch(err => this.handleError(err))
  }
}
